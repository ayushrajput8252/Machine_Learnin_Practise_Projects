# -*- coding: utf-8 -*-
"""PyTorch Breast_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K_q9qqg-lcSZ_WIQAPV-CPWSf7wbdM1F
"""

import torch
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder

df = pd.read_csv('https://raw.githubusercontent.com/gscdit/Breast-Cancer-Detection/refs/heads/master/data.csv')

df.head()

df.drop(columns=['id', 'Unnamed: 32'], inplace=True)

df.head()

label = LabelEncoder()
df['diagnosis'] = label.fit_transform(df['diagnosis'])

x = df.drop('diagnosis',axis=1)
y =  df['diagnosis']

x

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_test = scaler.transform(x_test)

x_train

y_train

x_train_tensor = torch.from_numpy(x_train)
x_test_tensor = torch.from_numpy(x_test)
y_train_tensor = torch.from_numpy(y_train.values).double()
y_test_tensor = torch.from_numpy(y_test.values).double()

y_train_tensor.shape

"""### **DEFINING THE MODEL**"""

class MySimpleNN():
  def __init__(self, x):

    self.weight = torch.rand(x.shape[1], 1, dtype=torch.float64, requires_grad=True)
    self.bias   = torch.zeros(1, dtype=torch.float64, requires_grad=True)

  def forward(self, x):
    z = torch.matmul(x, self.weight) + self.bias
    y_pred = torch.sigmoid(z)
    return y_pred

  def loss(self, x, y_true): # Added y_true as argument
    import torch.nn.functional as F
    # Reshape y_true to match y_pred's shape (batch_size, 1)
    bce_loss = F.binary_cross_entropy(self.forward(x), y_true.unsqueeze(1))
    return bce_loss

"""### **IMPORTANT PARAMETER**

"""

learning_rate = 0.1
epochs = 25

"""## **TRANING PIPELINE**"""

model = MySimpleNN(x_train_tensor)
epochs = 25
#loop structure
for epochs in range(epochs):

#forward pass
  y_pred = model.forward(x_train_tensor)
#loss cal
  loss = model.loss(x_train_tensor, y_train_tensor) # Pass y_train_tensor to loss function
#backward pro
  loss.backward()
#weight update
  with torch.no_grad():
    model.weight -= learning_rate * model.weight.grad
    model.bias -= learning_rate * model.bias.grad

    model.weight.grad.zero_()
    model.bias.grad.zero_()

    print(f'Epoch {epochs + 1}, Loss : {loss.item()}')

"""### **EVALUATING**"""

with torch.no_grad():
  y_pred = model.forward(x_test_tensor)
  y_pred = (y_pred > 0.5).float()
  accuracy = (y_pred == y_test_tensor.unsqueeze(1)).float().mean()
  print(f'Accuracy: {accuracy.item()}')

